# ordenaSeleccion
Análisis de complejidad temporal:
El algoritmo recorre n*n pasos ya que usa dos ciclos el primero va de i = 0 hasta el tamaño del arreglo y el segundo va de desde j = i+1 hasta el tamaño del arreglo, por lo que su complejidad es O(n^2) para el peor de los casos.

# ordena Burbuja
Análisis de complejidad temporal:
El algoritmo recorre n*n pasos ya que usa dos ciclos el primero va de i = 0 hasta el tamaño del arreglo y el segundo va de desde j = 0 hasta el tamaño del arreglo menos i menos 1 hasta el tamaño del arreglo, por lo que su complejidad es O(n^2) para el peor de los casos.

# ordenaMerge
Análisis de complejidad temporal:
El algoritmo recorre los pasos en subtipos, dividiendose a su vez generando una especie de arbol, por lo que su complejidad es de O(nlog(n)) para el peor de los casos.

# busqSecuencial
Análisis de complejidad temporal:
El algoritmo recorre n pasos ya que usa un ciclo que va i = 0 hasta el tamaño del arreglo, por lo que su complejidad es O(n) para el peor de los casos.

# busqBinaria
Análisis de complejidad temporal:
El algoritmo recursivo recorre los pasos en subtipos, dividiendose a su vez con ayuda de una función auxiliar, como si fuera un árbol por lo que su complejidad es de O(log(n)).
